1 билет 
Двоично — десятичная система счисления. 
4-х разрядное арифметико логическое устройство. Графическое обозначение. 
2 билет
Двоично — шестнадцатиричная система счисления. 
Микроконтроллер. Описание. 
3 билет
Логический элемент «НЕ».  Графическое обозначение, таблица истинности. 
Дещифратор на 2 входа. Графическое обозначение, таблица истинности. 
4 билет
логический элемент «2 И».  Графическое обозначение, таблица истинности.
Дещифратор на 3 входа. Графическое обозначение, таблица истинности. 
5 билет
Логический элемент «3 И».  Графическое обозначение, таблица истинности.
Дещифратор на 4 входа. Графическое обозначение, таблица истинности. 
6 билет 
Логический элемент «4 И».  Графическое обозначение, правило для логического элемента. 
Дещифратор для семисегментного индикатора. Графическое обозначение, таблица истинности
7 билет
Логический элемент «5 И».  Графическое обозначение, правило для логического элемента. 
Шифратор. Графическое обозначение, таблица истинности. 
8 билет
Логический элемент «Исключающее ИЛИ». Графическое обозначение, таблица истинности. 
RS - триггер. Графическое обозначение, таблица истинности. 
9 билет
Логический элемент «7 И». Графическое обозначение, правило для логического элемента. 
D - триггер. Графическое обозначение, таблица истинности. 
10 билет
Логический элемент «8 И».  Графическое обозначение, правило для логического элемента. 
T - триггер. Графическое обозначение, таблица истинности. 
11 билет
Логический элемент «2 ИЛИ».  Графическое обозначение, правило для логического элемента. 
JK - триггер. Графическое обозначение, таблица истинности. 
12 билет
Логический элемент «Исключающее ИЛИ-НЕ». Графическое обозначение, таблица 
Параллельный 4-х разрядный регистр. Графическое обозначение. 
13 билет
Логический элемент «4 ИЛИ».  Графическое обозначение, правило для логического элемента. 
Параллельный 8-ми разрядный регистр. Графическое обозначение. 
14 билет
Логический элемент «5 ИЛИ».  Графическое обозначение, правило для логического элемента. 
Параллельно - последовательный регистр. Графическое обозначение. 
15 билет
Логический элемент «6 ИЛИ». Графическое обозначение, правило для логического элемента. 
Последовательно - параллельный регистр. Графическое обозначение. 
16 билет 
Логический элемент «7 ИЛИ».  Графическое обозначение, правило для логического элемента. 
Полусумматор. Графическое обозначение, таблица истинности. 
17 билет
Логический элемент «8 ИЛИ».  Графическое обозначение, правило для логического элемента. 
Сумматор. Графическое обозначение, таблица истинности. 
18 билет
Логический элемент «2 И-НЕ».  Графическое обозначение, таблица истинности. 
Арифметико логическое устройство, сколько и каких выполняет операций? 
19 билет 
Логический элемент «3 И-НЕ».  Графическое обозначение, таблица истинности. 
Мультиплексор на 5 входов данных. Графическое обозначение, таблица истинности. 
20 билет 
Логический элемент «4 И-НЕ».  Графическое обозначение, правило для логического элемента. 
Последовательный периферийный интерфейс – SPI. 
21 билет
Логический элемент «5 И-НЕ».  Графическое обозначение, правило для логического элемента. 
Мультиплексор на 7 входов данных. Графическое обозначение, таблица истинности. 
22 билет
Логический элемент «6 И-НЕ».  Графическое обозначение, правило для логического элемента. 
Мультиплексор на 4 входа данных. Графическое обозначение, таблица истинности. 
23 билет
Логический элемент «7 И-НЕ». Графическое обозначение, правило для логического элемента. 
Универсальный синхронный последовательный приемопередатчик. 
24 билет
Логический элемент «8 И-НЕ».  Графическое обозначение, правило для логического элемента. 
Мультиплексор на 2 входа данных. Графическое обозначение, таблица истинности. 
25 билет
Логический элемент «2 ИЛИ-НЕ».  Графическое обозначение, таблица истинности. 
Типовая микропроцессорная система. Описание, схема. 
26 билет
Логический элемент «3 ИЛИ-НЕ».  Графическое обозначение, таблица истинности. 
Универсальный асинхронный последовательный приемопередатчик — УАПП - UART. 
27 билет
логический элемент «4 ИЛИ-НЕ». Графическое обозначение, правило для логического
элемента.
Двухпроводной последовательный интерфейс - TWI. 
28 билет
Логический элемент «5 ИЛИ-НЕ». Графическое обозначение, правило для логического элемента
Демультиплексор на 4 выхода данных. Графическое обозначение, таблица истинности. 
29 билет
логический элемент «6 ИЛИ-НЕ». Графическое обозначение, правило для логического 
элемента. 
Последовательная шина - I2C. 
30 билет
Логический элемент «7 ИЛИ-НЕ». Графическое обозначение, правило для логического элемента
Опишите транзисторно-транзисторная логику — ТТЛ - TTL. 


1 Билет
Двоично-десятичная система счисления.

Двоичная система: основана на числе 2, использует символы 0 и 1.
Десятичная система: основана на числе 10, использует символы 0-9.
Двоично-десятичная система (BCD - Binary Coded Decimal): используется для представления десятичных чисел в двоичном формате, где каждая десятичная цифра кодируется четырьмя двоичными разрядами.
4-х разрядное арифметико-логическое устройство (АЛУ).

АЛУ выполняет арифметические и логические операции.
Графическое обозначение 4-разрядного АЛУ:
plaintext
Копировать код
 ____________
|            |
|    ALU     |
|____________|
   | | | |
  A B C D
2 Билет
Двоично-шестнадцатеричная система счисления.

Шестнадцатеричная система: основана на числе 16, использует символы 0-9 и A-F.
Преобразование: каждые четыре двоичных разряда представляют одну шестнадцатеричную цифру.
Микроконтроллер. Описание.

Микроконтроллер: микропроцессор с встроенной памятью и периферийными устройствами.
Основные компоненты: центральный процессор (CPU), память (RAM, ROM), периферийные устройства (таймеры, порты ввода-вывода).
Применение: встраиваемые системы, управление аппаратурой.
3 Билет
Логический элемент «НЕ».

Графическое обозначение:
plaintext
Копировать код
 ___
|   \
|    \
|    /
|__ /
Таблица истинности:
A	NOT A
0	1
1	0
Дешифратор на 2 входа.

Графическое обозначение:
plaintext
Копировать код
   A B
    |
   ____
  |    |
  | D2 |
  |____|
 / | | \
Y0 Y1 Y2 Y3
Таблица истинности:
A	B	Y0	Y1	Y2	Y3
0	0	1	0	0	0
0	1	0	1	0	0
1	0	0	0	1	0
1	1	0	0	0	1
4 Билет
Логический элемент «2 И».

Графическое обозначение:
plaintext
Копировать код
   A   B
    \  /
     \/
    ____
   | AND |
   |_____|
      |
      Y
Таблица истинности:
A	B	Y
0	0	0
0	1	0
1	0	0
1	1	1
Дешифратор на 3 входа.

Графическое обозначение:
plaintext
Копировать код
   A B C
    |
   ____
  |    |
  | D3 |
  |____|
 / | | | | | | \
Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7
Таблица истинности:
A	B	C	Y0	Y1	Y2	Y3	Y4	Y5	Y6	Y7
0	0	0	1	0	0	0	0	0	0	0
0	0	1	0	1	0	0	0	0	0	0
0	1	0	0	0	1	0	0	0	0	0
0	1	1	0	0	0	1	0	0	0	0
1	0	0	0	0	0	0	1	0	0	0
1	0	1	0	0	0	0	0	1	0	0
1	1	0	0	0	0	0	0	0	1	0
1	1	1	0	0	0	0	0	0	0	1
5 Билет
Логический элемент «3 И».

Графическое обозначение:
plaintext
Копировать код
   A   B   C
    \  |  /
     \ | /
      \|/
    ____
   | AND |
   |_____|
      |
      Y
Таблица истинности:
A	B	C	Y
0	0	0	0
0	0	1	0
0	1	0	0
0	1	1	0
1	0	0	0
1	0	1	0
1	1	0	0
1	1	1	1
Дешифратор на 4 входа.

Графическое обозначение:
plaintext
Копировать код
   A B C D
    |
   ____
  |    |
  | D4 |
  |____|
 / | | | | | | | | | | | | | | | \
Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
Таблица истинности:
A	B	C	D	Y0	Y1	Y2	Y3	Y4	Y5	Y6	Y7	Y8	Y9	Y10	Y11	Y12	Y13	Y14	Y15
0	0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0	0	0	1	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
0	0	1	0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0
0	0	1	1	0	0	0	1	0	0	0	0	0	0	0	0	0	0	0	0
0	1	0	0	0	0	0	0	1	0	0	0	0	0	0	0	0	0	0	0
0	1	0	1	0	0	0	0	0	1	0	0	0	0	0	0	0	0	0	0
0	1	1	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0	0	0
0	1	1	1	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0	0
1	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0
1	0	0	1	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0
1	0	1	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0
1	0	1	1	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0	0
1	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0
1	1	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0	0
1	1	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1	0
1	1	1	1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	1
6 Билет
Логический элемент «4 И».

Графическое обозначение:
plaintext
Копировать код
   A   B   C   D
    \  |  |  /
     \ |  | /
      \|  |/
       \ /
        V
      ____
     | AND |
     |_____|
        |
        Y
Правило для логического элемента: выход истинный (1), только если все входы истинны (1).
Дешифратор для семисегментного индикатора.

Графическое обозначение:
plaintext
Копировать код
   ____
  |    |
  | D7 |
  |____|
 / | | | | | | \
a b c d e f g
Таблица истинности (пример для цифр 0-9):
Input	a	b	c	d	e	f	g
0000	1	1	1	1	1	1	0
0001	0	1	1	0	0	0	0
0010	1	1	0	1	1	0	1
0011	1	1	1	1	0	0	1
0100	0	1	1	0	0	1	1
0101	1	0	1	1	0	1	1
0110	1	0	1	1	1	1	1
0111	1	1	1	0	0	0	0
1000	1	1	1	1	1	1	1
1001	1	1	1	1	0	1	1
7 Билет
Логический элемент «5 И».

Графическое обозначение:
plaintext
Копировать код
   A   B   C   D   E
    \  |  |  |  /
     \ |  |  | /
      \|  |  |/
       \ |  /
        \| /
         V
      ____
     | AND |
     |_____|
        |
        Y
Правило для логического элемента: выход истинный (1), только если все входы истинны (1).
Шифратор.

Графическое обозначение:
plaintext
Копировать код
 ______
|      |
| ENC  |
|______|
 | | | |
Y0 Y1 Y2 Y3
Таблица истинности (пример для 8-входного шифратора):
Input	Output
0001	000
0010	001
0100	010
1000	011
0001	100
0011	101
0110	110
1100	111
8 Билет
Логический элемент «Исключающее ИЛИ».

Графическое обозначение:
plaintext
Копировать код
   A   B
    \ /
     X
    ____
   | XOR |
   |_____|
      |
      Y
Таблица истинности:
A	B	Y
0	0	0
0	1	1
1	0	1
1	1	0
RS-триггер.

Графическое обозначение:

plaintext
Копировать код
  ______
 |      |
 |  RS  |
 |______|
 | |   | |
 S R   Q Q'
Таблица истинности:

S	R	Q	Q'
0	0	Q	Q'
0	1	0	1
1	0	1	0
1	1	X	X
X означает запрещённое состояние (неопределённое).
9 Билет
Логический элемент «7 И».

Графическое обозначение:
plaintext
Копировать код
   A   B   C   D   E   F   G
    \  |  |  |  |  |  /
     \ |  |  |  |  | /
      \|  |  |  |  |/
       \ |  |  |  /
        \|  |  /
         \  | /
          \ |/
           V
         ____
        | AND |
        |_____|
           |
           Y
Правило для логического элемента: выход истинный (1), только если все входы истинны (1).
D-триггер.

Графическое обозначение:
plaintext
Копировать код
  ______
 |      |
 |  D   |
 |______|
 | |   | |
 D CLK Q Q'
Таблица истинности:
D	CLK	Q	Q'
0	0	Q	Q'
1	0	Q	Q'
0	1	0	1
1	1	1	0
10 Билет
Логический элемент «8 И».

Графическое обозначение:
plaintext
Копировать код
   A   B   C   D   E   F   G   H
    \  |  |  |  |  |  |  /
     \ |  |  |  |  |  | /
      \|  |  |  |  |  |/
       \ |  |  |  |  /
        \|  |  |  /
         \ |  | /
          \|  /
           V
         ____
        | AND |
        |_____|
           |
           Y
Правило для логического элемента: выход истинный (1), только если все входы истинны (1).
T-триггер.

Графическое обозначение:
plaintext
Копировать код
  ______
 |      |
 |  T   |
 |______|
 | |   | |
 T CLK Q Q'
Таблица истинности:
T	CLK	Q	Q'
0	0	Q	Q'
1	0	Q	Q'
0	1	Q	Q'
1	1	Q'	Q
11 Билет
Логический элемент «2 ИЛИ».

Графическое обозначение:
plaintext
Копировать код
   A   B
    \ /
     \/
    ____
   | OR  |
   |_____|
      |
      Y
Правило для логического элемента: выход истинный (1), если хотя бы один из входов истинный (1).
JK-триггер.

Графическое обозначение:
plaintext
Копировать код
  ______
 |      |
 |  JK  |
 |______|
 | |   | |
 J K  Q Q'
Таблица истинности:
J	K	Q	Q'
0	0	Q	Q'
0	1	0	1
1	0	1	0
1	1	Q'	Q
12 Билет
Логический элемент «Исключающее ИЛИ-НЕ».

Графическое обозначение:
plaintext
Копировать код
   A   B
    \ /
     X
     |
    __
   |  |
   |XNOR|
   |____|
      |
      Y
Таблица истинности:
A	B	Y
0	0	1
0	1	0
1	0	0
1	1	1
Параллельный 4-разрядный регистр.

Графическое обозначение:
plaintext
Копировать код
  _______
 |       |
 | 4-bit |
 | PAR   |
 | REG   |
 |_______|
 | | | | |
D0 D1 D2 D3
13 Билет
Логический элемент «4 ИЛИ».

Графическое обозначение:
plaintext
Копировать код
   A   B   C   D
    \  |  |  /
     \ |  | /
      \|  |/
       \ |
        \|
         V
        ____
       | OR  |
       |_____|
          |
          Y
Правило для логического элемента: выход истинный (1), если хотя бы один из входов истинный (1).
Параллельный 8-разрядный регистр.

Графическое обозначение:
plaintext
Копировать код
  _______
 |       |
 | 8-bit |
 | PAR   |
 | REG   |
 |_______|
 | | | | | | | | |
D0 D1 D2 D3 D4 D5 D6 D7
14 Билет
Логический элемент «5 ИЛИ».

Графическое обозначение:
plaintext
Копировать код
   A   B   C   D   E
    \  |  |  |  /
     \ |  |  | /
      \|  |  |/
       \ |  /
        \| /
         V
        ____
       | OR  |
       |_____|
          |
          Y
Правило для логического элемента: выход истинный (1), если хотя бы один из входов истинный (1).
Параллельно-последовательный регистр.

Графическое обозначение:
plaintext
Копировать код
  ______________
 |              |
 | PAR-SER      |
 | REG          |
 |______________|
 | | | | |      |
D0 D1 D2 D3    Q
15 Билет
Логический элемент «6 ИЛИ».

Графическое обозначение:
plaintext
Копировать код
   A   B   C   D   E   F
    \  |  |  |  |  /
     \ |  |  |  | /
      \|  |  |  |/
       \ |  |  /
        \|  | /
         \  |/
          \ |
           \|
            V
           ____
          | OR  |
          |_____|
             |
             Y
Правило для логического элемента: выход истинный (1), если хотя бы один из входов истинный (1).
Последовательно-параллельный регистр.

Графическое обозначение:
plaintext
Копировать код
  ______________
 |              |
 | SER-PAR      |
 | REG          |
 |______________|
 |              |
 | Q           D0 D1 D2 D3
16 Билет
Логический элемент «7 ИЛИ».

Графическое обозначение:
plaintext
Копировать код
   A   B   C   D   E   F   G
    \  |  |  |  |  |  /
     \ |  |  |  |  | /
      \|  |  |  |  |/
       \ |  |  |  /
        \|  |  /
         \ | /
          \|/
           V
          ____
         | OR  |
         |_____|
            |
            Y
Правило для логического элемента: выход истинный (1), если хотя бы один из входов истинный (1).
Полусумматор.

Графическое обозначение:
plaintext
Копировать код
  _______
 |       |
 | HALF  |
 | ADDER |
 |_______|
  |   |
  S   C
Таблица истинности:
A	B	S	C
0	0	0	0
0	1	1	0
1	0	1	0
1	1	0	1
17 Билет
Логический элемент «8 ИЛИ».

Графическое обозначение:
plaintext
Копировать код
   A   B   C   D   E   F   G   H
    \  |  |  |  |  |  |  /
     \ |  |  |  |  |  | /
      \|  |  |  |  |  |/
       \ |  |  |  |  /
        \|  |  |  /
         \ |  | /
          \|  /
           V
         ____
        | OR  |
        |_____|
           |
           Y
Правило для логического элемента: выход истинный (1), если хотя бы один из входов истинный (1).
Полный сумматор.

Графическое обозначение:
plaintext
Копировать код
  _______
 |       |
 | FULL  |
 | ADDER |
 |_______|
  | |   |
 S C_out C_in
Таблица истинности:
A	B	C_in	S	C_out
0	0	0	0	0
0	0	1	1	0
0	1	0	1	0
0	1	1	0	1
1	0	0	1	0
1	0	1	0	1
1	1	0	0	1
1	1	1	1	1
18 Билет
Логический элемент «И-НЕ».

Графическое обозначение:
plaintext
Копировать код
   A   B
    \ /
     \
      |\
      | V
     ____
    | NAND|
    |_____|
       |
       Y
Таблица истинности:
A	B	Y
0	0	1
0	1	1
1	0	1
1	1	0
Шифратор.

Графическое обозначение:
plaintext
Копировать код
 ______
|      |
| ENC  |
|______|
 | | | |
Y0 Y1 Y2 Y3
Таблица истинности (пример для 8-входного шифратора):
Input	Output
0001	000
0010	001
0100	010
1000	011
0001	100
0011	101
0110	110
1100	111
19 Билет
Логический элемент «ИЛИ-НЕ».

Графическое обозначение:
plaintext
Копировать код
   A   B
    \ /
     \
      |\
      | V
     ____
    | NOR |
    |_____|
       |
       Y
Таблица истинности:
A	B	Y
0	0	1
0	1	0
1	0	0
1	1	0
Дешифратор.

Графическое обозначение:
plaintext
Копировать код
   ____
  |    |
  | D8 |
  |____|
 / | | | | | | | \
a b c d e f g h
Таблица истинности (пример для цифр 0-9):
Input	a	b	c	d	e	f	g
0000	1	1	1	1	1	1	0
0001	0	1	1	0	0	0	0
0010	1	1	0	1	1	0	1
0011	1	1	1	1	0	0	1
0100	0	1	1	0	0	1	1
0101	1	0	1	1	0	1	1
0110	1	0	1	1	1	1	1
0111	1	1	1	0	0	0	0
1000	1	1	1	1	1	1	1
1001	1	1	1	1	0	1	1
20 Билет
Логический элемент «2 ИЛИ-НЕ».

Графическое обозначение:
plaintext
Копировать код
   A   B
    \ /
     \
      |\
      | V
     ____
    | NOR |
    |_____|
       |
       Y
Таблица истинности:
A	B	Y
0	0	1
0	1	0
1	0	0
1	1	0
Регистр сдвига.

Графическое обозначение:
plaintext
Копировать код
  _______
 |       |
 | SHIFT |
 | REG   |
 |_______|
 | | | | |
D Q1 Q2 Q3

1 билет

int photoresistorPin = A1; // Пин для фоторезистора
int ledPin = 10; // Пин для светодиода

void setup() {
  pinMode(photoresistorPin, INPUT); // Устанавливаем пин фоторезистора как вход
  pinMode(ledPin, OUTPUT); // Устанавливаем пин светодиода как выход
}

void loop() {
  int lightLevel = analogRead(photoresistorPin); // Считываем уровень освещенности

  // Преобразуем значение с фоторезистора в диапазон яркости светодиода
  int brightness = map(lightLevel, 0, 1023, 0, 255);

  // Устанавливаем яркость светодиода
  analogWrite(ledPin, brightness);

  delay(200); // Задержка для стабилизации
}

2билет

int photoresistorPin = A1; // Пин для фоторезистора
int ledPin = 10; // Пин для светодиода

void setup() {
  pinMode(photoresistorPin, INPUT); // Устанавливаем пин фоторезистора как вход
  pinMode(ledPin, OUTPUT); // Устанавливаем пин светодиода как выход
}

void loop() {
  int lightLevel = analogRead(photoresistorPin); // Считываем уровень освещенности

  // Если уровень освещенности ниже порогового значения, выключаем светодиод
  if (lightLevel < 500) {
    digitalWrite(ledPin, LOW);
  } else {
    digitalWrite(ledPin, HIGH);
  }

  delay(200); // Задержка для стабилизации
}


3 билет

int y; // Переменная y - яркость
bool buttonPressed = false; // Переменная, отслеживающая нажатие кнопки

void setup() {
  pinMode(11, OUTPUT); // Режим для 11 пина для светодиода
  pinMode(2, INPUT);   // Режим 2 пина для кнопки
}

void loop() {
  if (digitalRead(2)) { // Считываем цифровой аналоговый сигнал 2 пина
    if (!buttonPressed) { // Если кнопка была только что нажата
      buttonPressed = true; // Устанавливаем флаг нажатия кнопки
      for (y = 0; y <= 255; y = y + 1) { // В цикле от 0 до 255 с шагом 1 увеличиваем яркость
        analogWrite(11, y); // На 11 пин подаем напряжение "y"
        delay(0); // Задержка 10 миллисекунд (скорость свечения)
      }
    }
  } else { // Если кнопка не нажата
    if (buttonPressed) { // Если кнопка была только что отпущена
      buttonPressed = false; // Сбрасываем флаг нажатия кнопки
      for (y = 255; y >= 0; y = y - 1) { // В цикле от 255 до 0 уменьшаем яркость каждый раз на 1
        analogWrite(11, y); // На 11 пин подаем напряжение "y"
        delay(0); // Задержка 10 миллисекунд (скорость угасания)
      }
    }
  }
}

4 билет const int LED = 9; // Контакт 9 для подключения светодиода
const int BUTTON = 2; // Контакт 2 для подключения кнопки
boolean lastButton = LOW; // Переменная для сохранения предыдущего состояния кнопки
boolean currentButton = LOW; // Переменная для сохранения текущего состояния кнопки
boolean ledOn = false; // Текущее состояние светодиода (включен/выключен)

void setup() {
  pinMode(LED, OUTPUT); // Сконфигурировать контакт светодиода как выход
  pinMode(BUTTON, INPUT); // Сконфигурировать контакт кнопки как вход
}

/*
* Функция сглаживания дребезга принимает в качестве аргумента предыдущее состояние
* кнопки и выдает фактическое.
*/
boolean debounce(boolean last) {
  boolean current = digitalRead(BUTTON); // Считать состояние кнопки
  if (last != current) // Если изменилось...
  {
    delay(5); // Ждем 5 мс
    current = digitalRead(BUTTON); // Считываем состояние кнопки снова
    return current; // Возвращаем состояние кнопки
  }
}

void loop() {
  currentButton = debounce(lastButton);
  if (lastButton == LOW && currentButton == HIGH) // Если нажатие…
  {
    ledOn = !ledOn; // Инвертировать значение состояния светодиода
  }
  lastButton = currentButton;
  digitalWrite(LED, ledOn); // Изменить статус состояния светодиода
}

5 билет

// даём разумные имена для пинов со светодиодом
// и потенциометром (англ potentiometer или просто «pot»)
#define LED_PIN     9
#define POT_PIN     A0
 
void setup()
{
  // пин со светодиодом — выход, как и раньше...
  pinMode(LED_PIN, OUTPUT);
 
  // ...а вот пин с потенциометром должен быть входом
  // (англ. «input»): мы хотим считывать напряжение,
  // выдаваемое им
  pinMode(POT_PIN, INPUT);
}
 
void loop()
{
  // заявляем, что далее мы будем использовать 2 переменные с
  // именами rotation и brightness, и что хранить в них будем
  // целые числа (англ. «integer», сокращённо просто «int»)
  int rotation, brightness;  
 
  // считываем в rotation напряжение с потенциометра:
  // микроконтроллер выдаст число от 0 до 1023
  // пропорциональное углу поворота ручки
  rotation = analogRead(POT_PIN);
 
  // в brightness записываем полученное ранее значение rotation
  // делённое на 4. Поскольку в переменных мы пожелали хранить
  // целые значения, дробная часть от деления будет отброшена.
  // В итоге мы получим целое число от 0 до 255
  brightness = rotation / 4;
 
  // выдаём результат на светодиод
  analogWrite(LED_PIN, brightness);
}

6 билет
const int LED=9; //Контакт 9 для подключения светодиода
const int BUTTON=2; //Контакт 2 для подключения кнопки
boolean lastButton = LOW; //Переменная для сохранения предыдущего состояния кнопки
boolean currentButton = LOW; //Переменная для сохранения текущего состояния кнопки
boolean ledOn = false; //Текущее состояние светодиода (включен/выключен)

void setup()
{
  pinMode (LED, OUTPUT); //Сконфигурировать контакт светодиода как выход
  pinMode (BUTTON, INPUT); //Сконфигурировать контакт кнопки как вход
}

/*
* Функция сглаживания дребезга принимает в качестве аргумента предыдущее состояние
* кнопки и выдает фактическое.
*/

boolean debounce(boolean last)
{
  boolean current = digitalRead(BUTTON); //Считать состояние кнопки
  if (last != current) //Если изменилось...
  {
    delay(5); //Ждем 5 мс
    current = digitalRead(BUTTON); //Считываем состояние кнопки снова
    return current; //Возвращаем состояние кнопки
  }
}

void loop()
{
  currentButton = debounce(lastButton);
  if (lastButton == LOW && currentButton == HIGH) //Если нажатие…
  {
    ledOn = !ledOn; //Инвертировать значение состояния светодиода
  }
  lastButton = currentButton;
  digitalWrite(LED, ledOn); //Изменить статус состояния светодиода
}

7 билет
const int buttonPin = 3;  // Пин для кнопки
const int led1Pin = 12;   // Пин для первого светодиода
const int led2Pin = 13;   // Пин для второго светодиода

int buttonState = 0;  // Переменная для хранения состояния кнопки
int lastButtonState = LOW;  // Переменная для хранения предыдущего состояния кнопки
int activeLed = led1Pin;  // Переменная для хранения активного светодиода

void setup() {
  pinMode(buttonPin, INPUT);  // Настройка пина кнопки как входа
  pinMode(led1Pin, OUTPUT);   // Настройка пина первого светодиода как выхода
  pinMode(led2Pin, OUTPUT);   // Настройка пина второго светодиода как выхода
  digitalWrite(led1Pin, LOW); // Выключаем первый светодиод
  digitalWrite(led2Pin, LOW); // Выключаем второй светодиод
}

void loop() {
  // Считываем состояние кнопки
  buttonState = digitalRead(buttonPin);

  // Если состояние кнопки изменилось с последнего раза
  if (buttonState != lastButtonState) {
    // Если кнопка нажата
    if (buttonState == HIGH) {
      // Выключаем текущий активный светодиод
      digitalWrite(activeLed, LOW);
      // Меняем активный светодиод
      activeLed = (activeLed == led1Pin) ? led2Pin : led1Pin;
      // Включаем новый активный светодиод
      digitalWrite(activeLed, HIGH);
    }
    // Запоминаем текущее состояние кнопки
    lastButtonState = buttonState;
  }
}
8 билет
const int buttonPin = 3;  // Пин для кнопки
const int led1Pin = 12;   // Пин для первого светодиода
const int led2Pin = 13;   // Пин для второго светодиода

int buttonState = 0;  // Переменная для хранения состояния кнопки
int lastButtonState = LOW;  // Переменная для хранения предыдущего состояния кнопки
int activeLed = led1Pin;  // Переменная для хранения активного светодиода

void setup() {
  pinMode(buttonPin, INPUT);  // Настройка пина кнопки как входа
  pinMode(led1Pin, OUTPUT);   // Настройка пина первого светодиода как выхода
  pinMode(led2Pin, OUTPUT);   // Настройка пина второго светодиода как выхода
  digitalWrite(led1Pin, LOW); // Выключаем первый светодиод
  digitalWrite(led2Pin, LOW); // Выключаем второй светодиод
}

void loop() {
  // Считываем состояние кнопки
  buttonState = digitalRead(buttonPin);

  // Если состояние кнопки изменилось с последнего раза
  if (buttonState != lastButtonState) {
    // Если кнопка нажата
    if (buttonState == HIGH) {
      // Выключаем текущий активный светодиод
      digitalWrite(activeLed, LOW);
      // Меняем активный светодиод
      activeLed = (activeLed == led1Pin) ? led2Pin : led1Pin;
      // Включаем новый активный светодиод
      digitalWrite(activeLed, HIGH);
    }
    // Запоминаем текущее состояние кнопки
    lastButtonState = buttonState;
  }
}
9 билет
#define but1S 2
#define but2R 3
#define led1Q 13
#define led2_Q 12

bool Memory = 0;

void setup() {
  pinMode ( but1S, INPUT_PULLUP);
  pinMode ( but2R, INPUT_PULLUP);
  pinMode ( led1Q, OUTPUT);
  pinMode ( led2_Q, OUTPUT);

}

void loop() {
   if (!digitalRead(but1S) & !digitalRead(but2R)) {
    digitalWrite(led1Q, 1);
    digitalWrite(led2_Q, 1);}
   
  else if (!digitalRead(but1S)) {
     Memory = 1;
  }
  else if (!digitalRead(but2R)){
    Memory = 0;
  }
    digitalWrite(led1Q, Memory);
    digitalWrite(led2_Q, !Memory);
   
}
10 билет
// Пины для подключения к JK-триггеру
const int jPin = 13;  // Пин для входа J
const int cPin = 12;  // Пин для входа C
const int kPin = 11;  // Пин для входа K
const int qPin = 2;   // Пин для вывода Q
const int notQPin = 3;// Пин для вывода /Q

// Переменные для хранения предыдущих состояний входов JK
int prevJState = LOW;
int prevCState = LOW;
int prevKState = LOW;

// Переменные для хранения текущего состояния триггера и его выходов
int qState = LOW;

void setup() {
  // Настройка пинов ввода-вывода
  pinMode(jPin, INPUT);
  pinMode(cPin, INPUT);
  pinMode(kPin, INPUT);
  pinMode(qPin, OUTPUT);
  pinMode(notQPin, OUTPUT);
}

void loop() {
  // Считываем состояния входов J, C и K
  int jState = digitalRead(jPin);
  int cState = digitalRead(cPin);
  int kState = digitalRead(kPin);
  
  // Если состояния входов изменились
  if (jState != prevJState || cState != prevCState || kState != prevKState) {
    // Обновляем состояние триггера
    updateJKCTrigger(jState, cState, kState);
    
    // Устанавливаем предыдущие состояния входов
    prevJState = jState;
    prevCState = cState;
    prevKState = kState;
  }
  
  // Управляем светодиодом в соответствии с состоянием триггера
  digitalWrite(qPin, qState);
  digitalWrite(notQPin, !qState);
}

void updateJKCTrigger(int jState, int cState, int kState) {
  // Если вход C установлен в HIGH
  if (cState == HIGH) {
    // Инвертируем состояние Q
    qState = !qState;
  }
  // Если вход C установлен в LOW
  else {
    // Если вход J установлен в HIGH
    if (jState == HIGH) {
      // Устанавливаем Q в HIGH, если вход K установлен в LOW
      if (kState == LOW) {
        qState = HIGH;
      }
    }
    // Если вход K установлен в HIGH
    else if (kState == HIGH) {
      // Устанавливаем Q в LOW, если вход J установлен в LOW
      if (jState == LOW) {
        qState = LOW;
      }
    }
  }
}
12 билет
int d=100;
void setup()
{
  pinMode(2, OUTPUT);
  pinMode(4, OUTPUT);
  pinMode(6, OUTPUT);
  pinMode(8, OUTPUT);
  pinMode(10, OUTPUT);
}

void loop()
{
  for (int a=2;a<10;a++)
  {
    digitalWrite(a, HIGH);
    delay(d);
    digitalWrite(a, LOW); 
  }
  for (int b=11;b>2;b--)
  {
    digitalWrite(b, HIGH);
    delay(d);
    digitalWrite(b, LOW);
  }    
}
13 билет
void setup() {
  // Настройка пинов для светодиодов
  pinMode(2, OUTPUT);
  pinMode(4, OUTPUT);
  pinMode(6, OUTPUT);
  pinMode(8, OUTPUT);
}

void loop() {
  // Включаем два крайних светодиода
  digitalWrite(2, HIGH);
  digitalWrite(8, HIGH);
  delay(1000); // Ждем 1 секунду

  // Перемещаемся к центру
  digitalWrite(2, LOW); // Выключаем крайний левый светодиод
  digitalWrite(8, LOW); // Выключаем крайний правый светодиод
  digitalWrite(4, HIGH); // Включаем внутренний левый светодиод
  digitalWrite(6, HIGH); // Включаем внутренний правый светодиод
  delay(1000); // Ждем 1 секунду

  // Возвращаемся к краям
  digitalWrite(4, LOW); // Выключаем внутренний левый светодиод
  digitalWrite(6, LOW); // Выключаем внутренний правый светодиод
  digitalWrite(2, HIGH); // Включаем крайний левый светодиод
  digitalWrite(8, HIGH); // Включаем крайний правый светодиод
  delay(1000); // Ждем 1 секунду
}
14 билет
// Объявляем пины для светодиодов
const int ledPin1 = 8;
const int ledPin2 = 6;
const int ledPin3 = 4;
const int ledPin4 = 2;

void setup() {
  // Настраиваем пины как выводы
  pinMode(ledPin1, OUTPUT);
  pinMode(ledPin2, OUTPUT);
  pinMode(ledPin3, OUTPUT);
  pinMode(ledPin4, OUTPUT);
}

void loop() {
  // Сначала включаем один светодиод
  digitalWrite(ledPin1, HIGH);
  digitalWrite(ledPin2, LOW);
  digitalWrite(ledPin3, LOW);
  digitalWrite(ledPin4, LOW);
  delay(1000);  // Ждем 1 секунду

  // Затем включаем два светодиода
  digitalWrite(ledPin1, HIGH);
  digitalWrite(ledPin2, HIGH);
  digitalWrite(ledPin3, LOW);
  digitalWrite(ledPin4, LOW);
  delay(1000);  // Ждем 1 секунду

  // Затем три светодиода
  digitalWrite(ledPin1, HIGH);
  digitalWrite(ledPin2, HIGH);
  digitalWrite(ledPin3, HIGH);
  digitalWrite(ledPin4, LOW);
  delay(1000);  // Ждем 1 секунду

  // Затем все четыре светодиода
  digitalWrite(ledPin1, HIGH);
  digitalWrite(ledPin2, HIGH);
  digitalWrite(ledPin3, HIGH);
  digitalWrite(ledPin4, HIGH);
  delay(1000);  // Ждем 1 секунду
  
  // После этого начинаем заново, выключая все светодиоды
  digitalWrite(ledPin1, LOW);
  digitalWrite(ledPin2, LOW);
  digitalWrite(ledPin3, LOW);
  digitalWrite(ledPin4, LOW);
  delay(1000);  // Ждем 1 секунду
}
15 билет
// Объявляем пины для светодиодов
const int ledPin1 = 8;
const int ledPin2 = 6;
const int ledPin3 = 4;
const int ledPin4 = 2;

void setup() {
  // Настраиваем пины как выводы
  pinMode(ledPin1, OUTPUT);
  pinMode(ledPin2, OUTPUT);
  pinMode(ledPin3, OUTPUT);
  pinMode(ledPin4, OUTPUT);
}

void loop() {
  // Включаем светодиод 1
  digitalWrite(ledPin1, HIGH);
  delay(1000);
  
  // Включаем светодиод 2
  digitalWrite(ledPin2, HIGH);
  delay(1000);
  
  // Включаем светодиод 3
  digitalWrite(ledPin3, HIGH);
  delay(1000);
  
  // Включаем светодиод 4
  digitalWrite(ledPin4, HIGH);
  delay(1000);

  // Задержка перед выключением светодиодов
  delay(1000);

  // Выключаем светодиоды в обратном порядке
  digitalWrite(ledPin4, LOW);
  delay(1000);
  digitalWrite(ledPin3, LOW);
  delay(1000);
  digitalWrite(ledPin2, LOW);
  delay(1000);
  digitalWrite(ledPin1, LOW);
  delay(1000);
}
16 билет
// Пины подключения светодиода
const int redPin = 6;
const int greenPin = 4;
const int bluePin = 2;

// Функция для плавного перехода между цветами
void smoothTransition(int redStart, int greenStart, int blueStart, int redEnd, int greenEnd, int blueEnd, int steps, int duration) {
    float redIncrement = float(redEnd - redStart) / steps;
    float greenIncrement = float(greenEnd - greenStart) / steps;
    float blueIncrement = float(blueEnd - blueStart) / steps;

    for (int i = 0; i <= steps; i++) {
        int redValue = redStart + (redIncrement * i);
        int greenValue = greenStart + (greenIncrement * i);
        int blueValue = blueStart + (blueIncrement * i);

        analogWrite(redPin, redValue);
        analogWrite(greenPin, greenValue);
        analogWrite(bluePin, blueValue);

        delay(duration / steps);
    }
}

void setup() {
    pinMode(redPin, OUTPUT);
    pinMode(greenPin, OUTPUT);
    pinMode(bluePin, OUTPUT);
}

void loop() {
    // Плавно переходить от красного к зеленому
    smoothTransition(255, 0, 0, 0, 255, 0, 100, 1000); // Измените значения по вашему желанию
    delay(1000); // Пауза между переходами
    // Плавно переходить от зеленого к синему
    smoothTransition(0, 255, 0, 0, 0, 255, 100, 1000); // Измените значения по вашему желанию
    delay(1000); // Пауза между переходами
    // Плавно переходить от синего к красному
    smoothTransition(0, 0, 255, 255, 0, 0, 100, 1000); // Измените значения по вашему желанию
    delay(1000); // Пауза между переходами
}
17 билет
const int redPin = 2;
const int greenPin = 4;
const int bluePin = 6;

void setup() {
  pinMode(redPin, OUTPUT);
  pinMode(greenPin, OUTPUT);
  pinMode(bluePin, OUTPUT);
}

void loop() {
  // Красный
  setColor(255, 0, 0);
  delay(1000); // Ждем 1 секунду

  // Оранжевый
  setColor(255, 165, 0);
  delay(1000);

  // Желтый
  setColor(255, 255, 0);
  delay(1000);

  // Зеленый
  setColor(0, 255, 0);
  delay(1000);

  // Голубой
  setColor(0, 255, 255);
  delay(1000);

  // Синий
  setColor(0, 0, 255);
  delay(1000);

  // Фиолетовый
  setColor(128, 0, 128);
  delay(1000);
}

// Функция для установки цвета
void setColor(int redValue, int greenValue, int blueValue) {
  analogWrite(redPin, redValue);
  analogWrite(greenPin, greenValue);
  analogWrite(bluePin, blueValue);
}
18 билет
int ledPinR = 11;
int ledPinG = 10;
int ledPinB = 9;
 
void setup() { 
  pinMode(ledPinR, OUTPUT); 
  pinMode(ledPinG, OUTPUT); 
  pinMode(ledPinB, OUTPUT); 
} 
 
void loop() { 
  int adcValue;

  adcValue = analogRead(A0); 
  analogWrite(ledPinR, map(adcValue, 0, 1023, 0, 255));

  adcValue = analogRead(A1); 
  analogWrite(ledPinG, map(analogRead(A1), 0, 1023, 0, 255)); 

  adcValue = analogRead(A2); 
  analogWrite(ledPinB, map(adcValue, 0, 1023, 0, 255)); 
  
}
19 билет
// C++ code
//
void setup()
{
  pinMode(9, INPUT);
  Serial.begin(9600);
  pinMode(4, OUTPUT);
  pinMode(8, INPUT);
  pinMode(3, OUTPUT);
  pinMode(7, INPUT);
  pinMode(5, OUTPUT);
  pinMode(11, OUTPUT);
}

void loop()
{
  delay(250); // Wait for 250 millisecond(s)
  if (digitalRead(9) == 1) {
    Serial.println("Rojo prendido");
    digitalWrite(4, HIGH);
  } else {
    digitalWrite(4, LOW);
  }
  if (digitalRead(8) == 1) {
    Serial.println("Verde prendido");
    digitalWrite(3, HIGH);
  } else {
    digitalWrite(3, LOW);
  }
  if (digitalRead(7) == 1) {
    Serial.println("Azul prenddo");
    digitalWrite(5, HIGH);
  } else {
    digitalWrite(5, LOW);
  }

  analogWrite(11, 50);
}
20 билет такой же как 16
Вопросы по Python
Типы данных, операторы, переменные, константы:

Типы данных: int, float, str, list, tuple, dict, set.
Операторы: арифметические (+, -, *, /), логические (and, or, not), сравнения (==, !=, <, >).
Переменные: используются для хранения данных.
Константы: используются редко, принято использовать переменные с заглавными буквами.
Операторы ветвления, выбора, цикла:

Ветвление: if, elif, else.
Выбор: нет специального оператора, используется if-elif.
Циклы: for, while.
Массивы одномерные и многомерные:

Одномерные: [1, 2, 3].
Многомерные: [[1, 2], [3, 4]].
Строки. Набор методов для работы со строками:

Методы: .upper(), .lower(), .strip(), .split(), .join(), .replace().
Функции (методы):

Определение: def имя_функции(параметры): тело функции.
Файловый ввод вывод. Работа с файлами:

Открытие: open('filename', 'mode').
Чтение: .read(), .readline(), .readlines().
Запись: .write(), .writelines().
Класс как абстрактный тип. Создание и использование классов:

Определение: class ИмяКласса:.
Использование: объект = ИмяКласса().
Использование Объектов и классов:

Создание объекта: obj = ClassName().
Вызов методов: obj.method().
Списки, кортежи, словари:

Списки: [1, 2, 3].
Кортежи: (1, 2, 3).
Словари: {'ключ': 'значение'}.
Компоненты для работы с текстом:

Строки и методы работы с ними.
Модули. Определение и подключение модулей:

Определение: файлы .py.
Подключение: import модуль.
Как можно принять результат ввода на клавиатуре?

input().
Как проверить, что все символы строки относятся к алфавитно-цифровым?

.isalnum().
В чем разница между списком и кортежем?

Список изменяемый, кортеж неизменяемый.
Объясните функцию range:

Генерирует последовательность чисел.
Что такое локальные и глобальные переменные в Python?

Локальные объявлены внутри функции.
Глобальные объявлены вне функции.
В чем разница между func и func()?

func: ссылка на функцию.
func(): вызов функции.
Объясните, как работает функция map:

Применяет функцию к каждому элементу итерируемого объекта.
Переменные в Python передаются по ссылке или по значению?

По ссылке.
Как развернуть список?

[::-1] или reversed().
Что означает self в классе?

Ссылка на текущий экземпляр класса.
Как объединить списки в Python?

или .extend().
В чем разница между списками и массивами?

Списки более гибкие, массивы требуют import array.
Назовите изменяемые и неизменяемые объекты:

Изменяемые: list, dict, set.
Неизменяемые: int, float, str, tuple.
Как округлить число до трех десятичных знаков?

round(число, 3).
Где быстрее поиск: в словарях или списках?

В словарях.
В чем разница между модулем и пакетом?

Модуль: один файл .py.
Пакет: набор модулей с init.py.
Как увеличить и уменьшить целое число в Python?

+=, -=.
Как проверить, существует ли значение в списке?

in.
В чем разница между append и extend?

append: добавляет элемент.
extend: добавляет элементы из другого списка.
В чем разница между pass, continue и break?

pass: ничего не делает.
continue: пропускает текущую итерацию.
break: выходит из цикла.
Какие типы данных поддерживаются в питоне?(5):

int, float, str, list, dict.
Как выполняется обработка исключений в Python?

try-except.
Tkinter. Создание окна приложения. Кнопки. Позиционирование:

python
Копировать код
import tkinter as tk
window = tk.Tk()
button = tk.Button(window, text="Click me")
button.pack()
window.mainloop()
Tkinter. Текстовая метка Label, Поле ввода Entry и другие элементы:

python
Копировать код
label = tk.Label(window, text="Label")
entry = tk.Entry(window)
Работа с базой SQLite:

python
Копировать код
import sqlite3
conn = sqlite3.connect('database.db')
cursor = conn.cursor()
cursor.execute("CREATE TABLE example (id INTEGER PRIMARY KEY, name TEXT)")
Python полностью поддерживает ООП?

Да.
Что может быть ключом в словаре:

Любой неизменяемый тип данных.
Для чего используется функция init:

Инициализация объектов класса.
Что такое синхронный код и асинхронный код:

Синхронный: выполнение по порядку.
Асинхронный: выполнение может переключаться между задачами.
Что такое генератор и чем отличается от итератора:

Генератор: функция с yield.
Итератор: объект с iter() и next().
Вопросы по Java
Назначения языка Java. Средства разработки приложений Java:

Назначение: создание кросс-платформенных приложений.
Средства разработки: JDK, Eclipse, IntelliJ IDEA.
Типы данных и операции над ними (язык Java):

Типы данных: int, float, double, char, String.
Операции: +, -, *, /, %, ==, !=, <, >, &&, ||.
Объектно-ориентированное программирование (Java):

Основные концепции: инкапсуляция, наследование, полиморфизм, абстракция.
Работа со строками (Java):

String, методы: .length(), .substring(), .charAt(), .toUpperCase().
Геттеры – сеттеры в Java:

java
Копировать код
public class Example {
    private int value;
    public int getValue() {
        return value;
    }
    public void setValue(int value) {
        this.value = value;
    }
}
Вопросы по Android Studio
Что такое Activity? Объясните, что такое Activity и какие состояния характерны для него. Жизненный цикл Activity:

Activity: элемент интерфейса.
Состояния: onCreate(), onStart(), onResume(), onPause(), onStop(), onDestroy().
Что такое AndroidManifest. Кратко объясните, что такое AndroidManifest и каковы его функции:

AndroidManifest.xml: описывает структуру и компоненты приложения.
Что такое Intent? Кратко объясните, что такое Intent и каковы его функции:

Intent: объект для запуска действий и передачи данных между компонентами.
Диалоговые окна Android. Какие диалоговые окна могут использоваться в Андроид приложении?

AlertDialog, ProgressDialog, DatePickerDialog.
Виды Layout. Ключевые отличия и свойства. Какие виды разметок экрана(layout) существуют в android:

LinearLayout, RelativeLayout, ConstraintLayout.
Исполняемые файлы на Android:

APK (Android Package).
Что такое View? Приведите примеры ViewGroup:

View: элемент интерфейса.
ViewGroup: контейнер для View (LinearLayout, RelativeLayout).
Структура проекта в Android Studio:

Папки: src, res, manifest.
Что такое SDK Manager и AVD Manager:

SDK Manager: управляет версиями SDK.
AVD Manager: создает и управляет виртуальными устройствами.
Создание простого меню:

java
Копировать код
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.menu_main, menu);
    return true;
}
Папка res/values. Использование ресурсов приложения:

Хранит ресурсы: strings.xml, colors.xml.
Инструментальные среды разработки мобильных приложений для операционной системы Android:

Android Studio, Eclipse с ADT.
Адаптеры и списки в Android:

ArrayAdapter, RecyclerView.Adapter.
Работа с графикой и изображениями (Android):

ImageView, Canvas, Bitmap.